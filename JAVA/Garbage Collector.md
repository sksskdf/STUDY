JVM언어들은 객체생성시 heap메모리가 사용된다.
만약 heap메모리의 잔여공간이 없다면 어떻게 될까?

- Memory management strategies
heap메모리는 왠만한 프로그래밍작업에 충분하더라도 물리적 메모리(RAM)의 일부를 차지하므로 제한적이다.
그러므로 프로그램의 메모리사용이 과다하다면 결국 충돌로 이어질것이다.
대부분의 프로그램에는 실행의 특정 지점에서 더 이상 사용되지 않는 객체가 있다. 즉, 나중에 메모리를 해제하고 재사용할 수 있다.
C나 C++과 같은 언어들은 메모리관리를 수동으로 해주어야 한다.
자원을 제어할 수 있다는 장점은 있지만 초보자의 경우 수동 메모리 관리 작업은 커다란 진입장벽이 되곤한다.

JVM은 자동화된 메모리 관리를 지원하기 때문에 더이상 사용하지 않는 객체의 메모리는 garbage collector가 자원을 해제해준다.

- Garbage Collector란?
GC는 더이상 사용되지 않는 메모리의 자원을 해제해준다.
GC는 알고리즘과 구현이 다양하지만 공통점을 두가지로 단순화할 수 있다.
첫번째 단계는 더 이상 사용하지않는 메모리를 확인하는 것이고,
두번째 단계는 이러한 메모리를 해제하는 것이다.
또한 삭제 단계 후에 압축 작업을 수행할 수 있다.
현재 사용되는 모든 객체는 인접한 큰 메모리 영역을 해제하고 단편화를 피하기 위해 서로 옆으로 이동한다.

쓰레기를 확인하기 위해 GC는 객체가 프로그램 내부에서 여전히 도달가능 한지 여부를 확인한다.
프로그램이나 도달 가능한 다른 객체에서 도달할 수 없는 모든 객체는 "쓰레기"로 간주되고 해당 메모리가 해제된다.

일부 알고리즘은 객체에 대한 추가 정보(예: 객체 생성 이후 시간)를 고려한다.
이러한 알고리즘을 generational garbage collector라고 부른다.
프로그램의 대부분의 객체는 생성 후 짧은 시간 동안만 사용된다. 
따라서 GC는 실행할 때마다 힙의 모든 객체를 검사할 필요가 없으며 
주로 최근에 생성된 객체에 초점을 맞추므로 가비지 수집 시간이 단축된다.

- GC 실행
Garbage Collection은 프로그램이 실행되는 동안 자동으로 수행된다.
JVM은 GC를 실행할 시기를 결정하는 것부터, 모든 작업을 자체적으로 처리한다.
예를 들어, 고정된 시간 간격 또는 남은 여유 heap메모리가 없을때 발생할 수 있다.

대부분의 경우 사용자는 GC의 작업방식이나 커스텀하는 방법을 몰라도 된다.
그러나 현대의 고부하 애플리케이션의 경우 이러한 지식은 유용할 수도 있다.

GC를 호출하는 두가지 방법이다.
System.gc();
Runtime.getRuntime().gc();

프로그래머는 가비지 수집기를 수동으로 실행해서는 안 되며 
이러한 호출은 GC 호출을 보장하지도 않는다. 테스트 환경에서만 사용하는 것이 좋다.




